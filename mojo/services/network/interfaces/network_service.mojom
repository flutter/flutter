// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

[DartPackage="mojo_services"]
module mojo;

import "mojo/public/interfaces/network/network_error.mojom";
import "network/interfaces/cookie_store.mojom";
import "network/interfaces/host_resolver.mojom";
import "network/interfaces/http_server.mojom";
import "network/interfaces/net_address.mojom";
import "network/interfaces/tcp_bound_socket.mojom";
import "network/interfaces/tcp_connected_socket.mojom";
import "network/interfaces/udp_socket.mojom";
import "network/interfaces/url_loader.mojom";
import "network/interfaces/url_loader_interceptor.mojom";
import "network/interfaces/web_socket.mojom";

// TODO Darin suggests that this should probably be two classes. One for
// high-level origin-build requests like WebSockets and HTTP, and the other for
// non-origin-bound low-level stuff like DNS, UDP, and TCP.
[ServiceName="mojo::NetworkService"]
interface NetworkService {
  CreateURLLoader(URLLoader& loader);

  GetCookieStore(CookieStore& cookie_store);

  CreateWebSocket(WebSocket& socket);

  // Creates a TCP socket bound to a given local address. This bound socket
  // can be used for creating a client or server socket on that local address.
  //
  // If you want to create a client socket to connect to a server and are in
  // the common case where you don't care about the local address it's bound
  // to, use CreateTCPConnectedSocket.
  //
  // The local address can specify 0 for the port to specify that the OS should
  // pick an available port for the given address, or it can pass 0 for the
  // address and port for the OS to pick both the local address and port. In
  // all success cases, the resulting local address will be passed to the
  // callback as bound_to.
  CreateTCPBoundSocket(NetAddress? local_address, TCPBoundSocket& bound_socket)
      => (NetworkError result, NetAddress? bound_to);

  // Creates a client socket connected to the given remote address. A local
  // address and port will be allocated for the connection and passed to the
  // callback on success.
  //
  // If you want control over the local address and port, instead use
  // CreateTCPBoundSocket.
  //
  // IMPORTANT: This does not work yet! We need to add a new parameter to
  // indicate the protocol type (IPv4 or IPv6) actually be able to create the
  // right type of socket. We also need to figure out how the client is supposed
  // to decide between IPv4 and IPv6 on a given system.
  CreateTCPConnectedSocket(NetAddress remote_address,
                           handle<data_pipe_consumer> send_stream,
                           handle<data_pipe_producer> receive_stream,
                           TCPConnectedSocket& client_socket)
      => (NetworkError result, NetAddress? local_address);

  CreateUDPSocket(UDPSocket& socket);

  // Starts an HTTP server running on the given local address. The delegate will
  // be notified with incoming connections.
  //
  // The local address can specify 0 for the port to specify that the OS should
  // pick an available port for the given address, or it can pass 0 for the
  // address and port for the OS to pick both the local address and port. In
  // all success cases, the resulting local address will be passed to the
  // callback as bound_to.
  CreateHttpServer(NetAddress local_address, HttpServerDelegate delegate)
      => (NetworkError result, NetAddress? bound_to);

  // Register a new url loader interceptor that will be used on any new
  // URLLoader created with the current connection to the network service.
  // Interceptors are chained. The last registered interceptor will received the
  // requests first and the responses last.
  RegisterURLLoaderInterceptor(URLLoaderInterceptorFactory factory);

  // Create a HostResolver that can be used to do ip <-> host lookups.
  CreateHostResolver(HostResolver& host_resolver);
};
