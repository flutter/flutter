Flutter
=======

Flutter is a new way to build high-performance, cross-platform mobile apps.
Flutter is optimized for today's — and tomorrow's — mobile devices. We are
focused on low-latency input and high frame rates on Android and iOS.

See the [getting started guide](https://flutter.io/getting-started/) for
information about using Flutter.

## How To Write International Flutter Applications

If your app might be deployed to users who speak another language you'll need to "internationalize" it. That means you'll need to write the app in a way that makes it possible to "localize" things like text and layouts for each language or "locale" that the app supports. Flutter provides widgets and classes that help with internationalization and the Flutter libraries themselves are internationalized.

The [Locale] class is used to identify the user's language. Mobile devices support setting the locale for all applications, usually via a system settings menu. Internationalized apps respond by redisplaying values that are locale-specific. For example if the user switches the device's locale from English to French then a Text widget that displayed "CANCEL" would be rebuilt with "ANNULER".

The [Localizations] widget defines the locale for its child and the localized resources that the child depends on. The `WidgetsApp` widget creates a Localizations widget and rebuilds it if the system's locale changes.

You can always lookup an app's current locale with `Localizations.localeOf()`:
```
Locale myLocale = Localizations.of(context);
```

The [Localizations] widget is used to load and lookup localized values. Apps refer to the Localizations widget with `Localizations.of(context, type)`. If the device's locale changes, the Localizations widget automatically loads values for the new locale and then rebuilds widgets that used it to look up localized values. This happens because Localizations is effectively an [InheritedWidget]. When a build function refers to an inherited widget an implicit dependency on the inherited widget is created. When an inherited widget changes, its dependent contexts are rebuilt.

Localized values are loaded by the Localizations widget's list of [LocalizationsDelegate]s. Each delegate must define an async `load()` method that produces an object which encapsulates a collection of values. Typically these objects provide one method per localized value.

In a large app, different modules or packages might be bundled with their own localizations. That's why the Localizations widget manages a table of objects, one per LocalizationsDelegate. To retrieve the object produced by one of the LocalizationsDelegate's `load` methods, you specify a BuildContext and the object's type.  For example the localized strings for the Material widgets are defined by the `MaterialLocalizations` class. Instances of this class are created by a LocalizationDelegate provided by the `MaterialApp` class. They can be retrieved with `Localizations.of`:

```dart
Localizations.of<MaterialLocalizations>(context, MaterialLocalizations);
```

This particular `Localizations.of()` expression is used frequently, so the MaterialLocalizations class provides a convenient shortand:

```dart
static MaterialLocalizations of(BuildContext context) {
  return Localizations.of<MaterialLocalizations>(context, MaterialLocalizations);
}

/// References to the localized values defined by MaterialLocalizations
/// are typically written like this:

tooltip: MaterialLocalizations.of(context).backButtonTooltip,
```

The example that follows can be viewed as a template for using Flutter's localizations classes. It defines a single class, MyLocalizations, that contains the app's localized resources (just one for the example). It uses the initializeMessages() function generated by the Dart intl package to load resources and Intl.message() to look them up.

```dart
class MyLocalizations {
  MyLocalizations(this.locale);

  final Locale locale;

  static Future<MyLocalizations> load(Locale locale) {
    return initializeMessages(locale.toString())
      .then((Null _) {
        return new MyLocalizations(locale);
      });
  }

  static MyLocalizations of(BuildContext context) {
    return Localizations.of<MyLocalizations>(context, MyLocalizations);
  }

  String title() => Intl.message('<title>', name: 'title', locale: locale.toString());
  // ... more Intl.message() methods like title()
}
```

A class based on the `intl` package imports a generated message catalog that provides
the `initializeMessages()` function and the per-locale backing store for `Intl.message()`.
The message catalog is produced by an `intl` tool that analyzes the source code for
classes that contain `Intl.message()` calls. In this case that would just be the
`MyLocalizations` class.

An instance of `MyLocalizations` is created by a simple LocalizationsDelegate:

```dart
class MyLocalizationsDelegate extends LocalizationsDelegate<MyStrings> {
  @override
  Future<MyStrings> load(Locale locale) => MyStrings.load(locale);

  @override
  bool shouldReload(MyLocalizationsDelegate old) => false;
}
```

An instance of `MyLocalizationsDelegate` is provided to application's MaterialApp (or its WidgetsApp for non-material applications):

```dart
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new MaterialApp(
      localizationsDelegates: <LocalizationsDelegate>[
        new MyLocalizationsDelegate()
      ],
      supportedLocales: <Locale>[
        const Locale('en', 'US'), // US English
        const Locale('fr', 'CA'), // Candian French
      ],
      child: home: new Scaffold(
        appBar: new AppBar(
          title: new Text(MyLocalizations.of(context).title),
          ...
        ),
      ),
    );
  }
}
```

As you can see, the app's `AppBar` title comes from an instance of `MyLocalizations` produced by `MyLocalizations.load()` via `MyLocalizationsDelegate`. If the device's locale changes, then the app will be rebuilt with a new `MyLocalizations` object, one constructed for the new locale. Any reference to `MyLocalizations.of()` anywhere in the app will causes its context to be rebuilt if the locale changes.

The [MaterialApp] `supportedLocales` parameter limits locale changes. In this case the app will only accept the US English or French Canadian locales and it will substitute US English (the first locale in the list) for anything else.
