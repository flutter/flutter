// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:convert';
import 'dart:typed_data';

import 'package:test/bootstrap/browser.dart';
import 'package:test/test.dart';
import 'package:ui/src/engine.dart';
import 'package:ui/ui.dart' as ui;
import 'package:web_engine_tester/golden_tester.dart';

import '../common/fake_asset_manager.dart';
import '../common/test_initialization.dart';
import 'utils.dart';

void main() {
  internalBootstrapBrowserTest(() => testMain);
}

// This fragment shader generates some voronoi noise. It uses a pseudo-random
// number generator implemented in the shader itself, so its output is
// deterministic.
// Generated from engine/src/flutter/lib/ui/fixtures/shaders/general_shaders/voronoi.frag
// For changes, update that file and regenerate using impellerc.
const String kVoronoiShaderSksl = r'''
{
  "format_version": 1,
  "sksl": {
    "entrypoint": "foo_fragment_main",
    "shader": "// This SkSL shader is autogenerated by spirv-cross.\n\nfloat4 flutter_FragCoord;\n\nuniform float uTileSize;\n\nvec4 fragColor;\n\nvec2 FLT_flutter_local_FlutterFragCoord()\n{\n    return flutter_FragCoord.xy;\n}\n\nfloat FLT_flutter_local_rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.98980045318603515625, 78.233001708984375))) * 43758.546875);\n}\n\nvec2 FLT_flutter_local_fuzzGridPoint(vec2 coordinate)\n{\n    vec2 param = coordinate * 400.0;\n    vec2 param_1 = coordinate * 400.0;\n    return coordinate + vec2((FLT_flutter_local_rand(param) - 0.5) * 0.800000011920928955078125, (FLT_flutter_local_rand(param_1) - 0.5) * 0.800000011920928955078125);\n}\n\nvec3 FLT_flutter_local_getColorForGridPoint(vec2 coordinate)\n{\n    vec2 param = coordinate * 100.0;\n    vec2 param_1 = coordinate * 200.0;\n    vec2 param_2 = coordinate * 300.0;\n    return vec3(FLT_flutter_local_rand(param), FLT_flutter_local_rand(param_1), FLT_flutter_local_rand(param_2));\n}\n\nvoid FLT_main()\n{\n    vec2 uv = FLT_flutter_local_FlutterFragCoord() / vec2(uTileSize);\n    vec2 upperLeft = floor(uv);\n    vec2 upperRight = vec2(ceil(uv.x), floor(uv.y));\n    vec2 bottomLeft = vec2(floor(uv.x), ceil(uv.y));\n    vec2 bottomRight = ceil(uv);\n    vec2 closestPoint = upperLeft;\n    vec2 param_3 = upperLeft;\n    float dist = distance(uv, FLT_flutter_local_fuzzGridPoint(param_3));\n    vec2 param_4 = upperRight;\n    float upperRightDistance = distance(uv, FLT_flutter_local_fuzzGridPoint(param_4));\n    if (upperRightDistance < dist)\n    {\n        dist = upperRightDistance;\n        closestPoint = upperRight;\n    }\n    vec2 param_5 = bottomLeft;\n    float bottomLeftDistance = distance(uv, FLT_flutter_local_fuzzGridPoint(param_5));\n    if (bottomLeftDistance < dist)\n    {\n        dist = bottomLeftDistance;\n        closestPoint = bottomLeft;\n    }\n    vec2 param_6 = bottomRight;\n    float bottomRightDistance = distance(uv, FLT_flutter_local_fuzzGridPoint(param_6));\n    if (bottomRightDistance < dist)\n    {\n        dist = bottomRightDistance;\n        closestPoint = bottomRight;\n    }\n    vec2 param_7 = closestPoint;\n    fragColor = vec4(FLT_flutter_local_getColorForGridPoint(param_7), 1.0);\n}\n\nhalf4 main(float2 iFragCoord)\n{\n      flutter_FragCoord = float4(iFragCoord, 0, 0);\n      FLT_main();\n      return fragColor;\n}\n",
    "stage": 1,
    "uniforms": [
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 0,
        "name": "uTileSize",
        "rows": 1,
        "type": 10
      }
    ]
  }
}''';

// Fragment shader that outputs the provided texture.
// Generated from engine/src/flutter/lib/ui/fixtures/shaders/general_shaders/texture.frag
// For changes, update that file and regenerate using impellerc.
const kTextureShaderSksl = r'''
{
  "format_version": 1,
  "sksl": {
    "entrypoint": "texture_fragment_main",
    "shader": "// This SkSL shader is autogenerated by spirv-cross.\n\nfloat4 flutter_FragCoord;\n\nuniform vec2 u_size;\nuniform shader u_texture;\nuniform half2 u_texture_size;\n\nvec4 frag_color;\n\nvec2 FLT_flutter_local_FlutterFragCoord()\n{\n    return flutter_FragCoord.xy;\n}\n\nvoid FLT_main()\n{\n    frag_color = u_texture.eval(u_texture_size * ( FLT_flutter_local_FlutterFragCoord() / u_size));\n}\n\nhalf4 main(float2 iFragCoord)\n{\n      flutter_FragCoord = float4(iFragCoord, 0, 0);\n      FLT_main();\n      return frag_color;\n}\n",
    "stage": 1,
    "uniforms": [
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 0,
        "name": "u_size",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 0,
        "columns": 1,
        "location": 1,
        "name": "u_texture",
        "rows": 1,
        "type": 12
      }
    ]
  }
}''';

// Generated from engine/src/flutter/impeller/fixtures/ink_sparkle.frag
// For changes, update that file and regenerate using impellerc.
const String kInkSparkleSksl = r'''
{
  "format_version": 1,
  "sksl": {
    "entrypoint": "ink_sparkle_fragment_main",
    "shader": "// This SkSL shader is autogenerated by spirv-cross.\n\nfloat4 flutter_FragCoord;\n\nuniform vec4 u_color;\nuniform float u_alpha;\nuniform vec4 u_sparkle_color;\nuniform float u_sparkle_alpha;\nuniform float u_blur;\nuniform vec2 u_center;\nuniform float u_radius_scale;\nuniform float u_max_radius;\nuniform vec2 u_resolution_scale;\nuniform vec2 u_noise_scale;\nuniform float u_noise_phase;\nuniform vec2 u_circle1;\nuniform vec2 u_circle2;\nuniform vec2 u_circle3;\nuniform vec2 u_rotation1;\nuniform vec2 u_rotation2;\nuniform vec2 u_rotation3;\n\nvec4 fragColor;\n\nvec2 FLT_flutter_local_FlutterFragCoord()\n{\n    return flutter_FragCoord.xy;\n}\n\nmat2 FLT_flutter_local_rotate2d(vec2 rad)\n{\n    return mat2(vec2(rad.x, -rad.y), vec2(rad.y, rad.x));\n}\n\nfloat FLT_flutter_local_soft_circle(vec2 uv, vec2 xy, float radius, float blur)\n{\n    float blur_half = blur * 0.5;\n    float d = distance(uv, xy);\n    return 1.0 - smoothstep(1.0 - blur_half, 1.0 + blur_half, d / radius);\n}\n\nfloat FLT_flutter_local_circle_grid(vec2 resolution, inout vec2 p, vec2 xy, vec2 rotation, float cell_diameter)\n{\n    vec2 param = rotation;\n    p = (FLT_flutter_local_rotate2d(param) * (xy - p)) + xy;\n    p = mod(p, vec2(cell_diameter)) / resolution;\n    float cell_uv = (cell_diameter / resolution.y) * 0.5;\n    float r = 0.64999997615814208984375 * cell_uv;\n    vec2 param_1 = p;\n    vec2 param_2 = vec2(cell_uv);\n    float param_3 = r;\n    float param_4 = r * 50.0;\n    return FLT_flutter_local_soft_circle(param_1, param_2, param_3, param_4);\n}\n\nfloat FLT_flutter_local_turbulence(vec2 uv)\n{\n    vec2 uv_scale = uv * vec2(0.800000011920928955078125);\n    vec2 param = vec2(0.800000011920928955078125);\n    vec2 param_1 = uv_scale;\n    vec2 param_2 = u_circle1;\n    vec2 param_3 = u_rotation1;\n    float param_4 = 0.17000000178813934326171875;\n    float _301 = FLT_flutter_local_circle_grid(param, param_1, param_2, param_3, param_4);\n    float g1 = _301;\n    vec2 param_5 = vec2(0.800000011920928955078125);\n    vec2 param_6 = uv_scale;\n    vec2 param_7 = u_circle2;\n    vec2 param_8 = u_rotation2;\n    float param_9 = 0.20000000298023223876953125;\n    float _313 = FLT_flutter_local_circle_grid(param_5, param_6, param_7, param_8, param_9);\n    float g2 = _313;\n    vec2 param_10 = vec2(0.800000011920928955078125);\n    vec2 param_11 = uv_scale;\n    vec2 param_12 = u_circle3;\n    vec2 param_13 = u_rotation3;\n    float param_14 = 0.2750000059604644775390625;\n    float _326 = FLT_flutter_local_circle_grid(param_10, param_11, param_12, param_13, param_14);\n    float g3 = _326;\n    float v = (((g1 * g1) + g2) - g3) * 0.5;\n    return clamp(0.449999988079071044921875 + (0.800000011920928955078125 * v), 0.0, 1.0);\n}\n\nfloat FLT_flutter_local_soft_ring(vec2 uv, vec2 xy, float radius, float thickness, float blur)\n{\n    vec2 param = uv;\n    vec2 param_1 = xy;\n    float param_2 = radius + thickness;\n    float param_3 = blur;\n    float circle_outer = FLT_flutter_local_soft_circle(param, param_1, param_2, param_3);\n    vec2 param_4 = uv;\n    vec2 param_5 = xy;\n    float param_6 = max(radius - thickness, 0.0);\n    float param_7 = blur;\n    float circle_inner = FLT_flutter_local_soft_circle(param_4, param_5, param_6, param_7);\n    return clamp(circle_outer - circle_inner, 0.0, 1.0);\n}\n\nfloat FLT_flutter_local_triangle_noise(inout vec2 n)\n{\n    n = fract(n * vec2(5.398700237274169921875, 5.442100048065185546875));\n    n += vec2(dot(n.yx, n + vec2(21.5351009368896484375, 14.3136997222900390625)));\n    float xy = n.x * n.y;\n    return (fract(xy * 95.43070220947265625) + fract(xy * 75.0496063232421875)) - 1.0;\n}\n\nfloat FLT_flutter_local_threshold(float v, float l, float h)\n{\n    return step(l, v) * (1.0 - step(h, v));\n}\n\nfloat FLT_flutter_local_sparkle(vec2 uv, float t)\n{\n    vec2 param = uv;\n    float _224 = FLT_flutter_local_triangle_noise(param);\n    float n = _224;\n    float param_1 = n;\n    float param_2 = 0.0;\n    float param_3 = 0.0500000007450580596923828125;\n    float s = FLT_flutter_local_threshold(param_1, param_2, param_3);\n    float param_4 = n + sin(3.1415927410125732421875 * (t + 0.3499999940395355224609375));\n    float param_5 = 0.100000001490116119384765625;\n    float param_6 = 0.1500000059604644775390625;\n    s += FLT_flutter_local_threshold(param_4, param_5, param_6);\n    float param_7 = n + sin(3.1415927410125732421875 * (t + 0.699999988079071044921875));\n    float param_8 = 0.20000000298023223876953125;\n    float param_9 = 0.25;\n    s += FLT_flutter_local_threshold(param_7, param_8, param_9);\n    float param_10 = n + sin(3.1415927410125732421875 * (t + 1.0499999523162841796875));\n    float param_11 = 0.300000011920928955078125;\n    float param_12 = 0.3499999940395355224609375;\n    s += FLT_flutter_local_threshold(param_10, param_11, param_12);\n    return clamp(s, 0.0, 1.0) * 0.550000011920928955078125;\n}\n\nvoid FLT_main()\n{\n    vec2 p = FLT_flutter_local_FlutterFragCoord();\n    vec2 uv_1 = p * u_resolution_scale;\n    vec2 density_uv = uv_1 - mod(p, u_noise_scale);\n    float radius = u_max_radius * u_radius_scale;\n    vec2 param_13 = uv_1;\n    float turbulence = FLT_flutter_local_turbulence(param_13);\n    vec2 param_14 = p;\n    vec2 param_15 = u_center;\n    float param_16 = radius;\n    float param_17 = 0.0500000007450580596923828125 * u_max_radius;\n    float param_18 = u_blur;\n    float ring = FLT_flutter_local_soft_ring(param_14, param_15, param_16, param_17, param_18);\n    vec2 param_19 = density_uv;\n    float param_20 = u_noise_phase;\n    float sparkle = ((FLT_flutter_local_sparkle(param_19, param_20) * ring) * turbulence) * u_sparkle_alpha;\n    vec2 param_21 = p;\n    vec2 param_22 = u_center;\n    float param_23 = radius;\n    float param_24 = u_blur;\n    float wave_alpha = (FLT_flutter_local_soft_circle(param_21, param_22, param_23, param_24) * u_alpha) * u_color.w;\n    vec4 wave_color = vec4(u_color.xyz * wave_alpha, wave_alpha);\n    vec4 sparkle_color = vec4(u_sparkle_color.xyz * u_sparkle_color.w, u_sparkle_color.w);\n    fragColor = mix(wave_color, sparkle_color, vec4(sparkle));\n}\n\nhalf4 main(float2 iFragCoord)\n{\n      flutter_FragCoord = float4(iFragCoord, 0, 0);\n      FLT_main();\n      return fragColor;\n}\n",
    "stage": 1,
    "uniforms": [
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 0,
        "name": "u_color",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 1,
        "name": "u_alpha",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 2,
        "name": "u_sparkle_color",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 3,
        "name": "u_sparkle_alpha",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 4,
        "name": "u_blur",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 5,
        "name": "u_center",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 6,
        "name": "u_radius_scale",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 7,
        "name": "u_max_radius",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 8,
        "name": "u_resolution_scale",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 9,
        "name": "u_noise_scale",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 10,
        "name": "u_noise_phase",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 11,
        "name": "u_circle1",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 12,
        "name": "u_circle2",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 13,
        "name": "u_circle3",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 14,
        "name": "u_rotation1",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 15,
        "name": "u_rotation2",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 16,
        "name": "u_rotation3",
        "rows": 2,
        "type": 10
      }
    ]
  }
}
''';

// Simple shader with a bunch of array uniforms
// Generated from engine/src/flutter/lib/ui/fixtures/shaders/general_shaders/many_arrays.frag
// For changes, update that file and regenerate using impellerc.
const String kManyArraysSksl = r'''
{
  "format_version": 1,
  "sksl": {
    "entrypoint": "foo_fragment_main",
    "shader": "// This SkSL shader is autogenerated by spirv-cross.\n\nfloat4 flutter_FragCoord;\n\nuniform vec2 uSize;\nuniform float uFloats[10];\nuniform float uLoneFloat;\nuniform vec2 uVectors[3];\nuniform vec3 uLoneVector;\nuniform mat4 uMatrices[2];\nuniform mat4 uLoneMatrix;\n\nvec4 fragColor;\n\nvec2 FLT_flutter_local_FlutterFragCoord()\n{\n    return flutter_FragCoord.xy;\n}\n\nvoid FLT_main()\n{\n    vec2 pos = FLT_flutter_local_FlutterFragCoord();\n    vec2 uv = pos / uSize;\n    float barWidth = 0.100000001490116119384765625;\n    float barIndex = floor(uv.x / barWidth);\n    for (int i = 0; i < 10; i++)\n    {\n        if (i == int(barIndex))\n        {\n            float barHeight = uFloats[i];\n            if (uv.y > (1.0 - barHeight))\n            {\n                fragColor = vec4(0.3300000131130218505859375, 0.0900000035762786865234375, 0.0900000035762786865234375, 1.0);\n            }\n            else\n            {\n                fragColor = vec4(1.0);\n            }\n        }\n    }\n}\n\nhalf4 main(float2 iFragCoord)\n{\n      flutter_FragCoord = float4(iFragCoord, 0, 0);\n      FLT_main();\n      return fragColor;\n}\n",
    "stage": 1,
    "uniforms": [
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 0,
        "name": "uSize",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 10,
        "bit_width": 32,
        "columns": 1,
        "location": 1,
        "name": "uFloats",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 11,
        "name": "uLoneFloat",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 3,
        "bit_width": 32,
        "columns": 1,
        "location": 12,
        "name": "uVectors",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 15,
        "name": "uLoneVector",
        "rows": 3,
        "type": 10
      },
      {
        "array_elements": 2,
        "bit_width": 32,
        "columns": 4,
        "location": 16,
        "name": "uMatrices",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 4,
        "location": 18,
        "name": "uLoneMatrix",
        "rows": 4,
        "type": 10
      }
    ]
  }
}
''';

Future<void> testMain() async {
  setUpUnitTests(withImplicitView: true, setUpTestViewDimensions: false);

  const region = ui.Rect.fromLTWH(0, 0, 300, 300);

  late FakeAssetScope assetScope;
  setUp(() {
    assetScope = fakeAssetManager.pushAssetScope();
    assetScope.setAsset('voronoi_shader', ByteData.sublistView(utf8.encode(kVoronoiShaderSksl)));
    assetScope.setAsset('texture_shader', ByteData.sublistView(utf8.encode(kTextureShaderSksl)));
    assetScope.setAsset('many_arrays', ByteData.sublistView(utf8.encode(kManyArraysSksl)));
    assetScope.setAsset('ink_sparkle', ByteData.sublistView(utf8.encode(kInkSparkleSksl)));
  });

  tearDown(() {
    fakeAssetManager.popAssetScope(assetScope);
  });

  test('fragment shader', () async {
    final ui.FragmentProgram program = await renderer.createFragmentProgram('voronoi_shader');
    final ui.FragmentShader shader = program.fragmentShader();

    Future<void> drawCircle(String goldenFilename) async {
      final recorder = ui.PictureRecorder();
      final canvas = ui.Canvas(recorder, region);
      canvas.drawCircle(const ui.Offset(150, 150), 100, ui.Paint()..shader = shader);

      await drawPictureUsingCurrentRenderer(recorder.endRecording());

      await matchGoldenFile(goldenFilename, region: region);
    }

    shader.setFloat(0, 10.0);
    await drawCircle('fragment_shader_voronoi_tile10px.png');

    // Make sure we can reuse the shader object with a new uniform value.
    shader.setFloat(0, 25.0);
    await drawCircle('fragment_shader_voronoi_tile25px.png');

    // Test reusing a Paint object with the same shader.
    final reusablePaint = ui.Paint()..shader = shader;

    Future<void> drawCircleReusePaint(String goldenFilename) async {
      final recorder = ui.PictureRecorder();
      final canvas = ui.Canvas(recorder, region);
      canvas.drawCircle(const ui.Offset(150, 150), 100, reusablePaint);

      await drawPictureUsingCurrentRenderer(recorder.endRecording());

      await matchGoldenFile(goldenFilename, region: region);
    }

    shader.setFloat(0, 10.0);
    await drawCircleReusePaint('fragment_shader_voronoi_tile10px_reuse_paint.png');

    // Make sure we can reuse the shader object with a new uniform value and the same Paint object.
    shader.setFloat(0, 25.0);
    await drawCircleReusePaint('fragment_shader_voronoi_tile25px_reuse_paint.png');
  }, skip: isWimp); // https://github.com/flutter/flutter/issues/175431

  for (final (filterQuality, goldenFilename) in [
    (ui.FilterQuality.none, 'web_fragment_shader_texture_with_quality_none.png'),
    (ui.FilterQuality.low, 'web_fragment_shader_texture_with_quality_low.png'),
    (ui.FilterQuality.medium, 'web_fragment_shader_texture_with_quality_medium.png'),
    (ui.FilterQuality.high, 'web_fragment_shader_texture_with_quality_high.png'),
  ]) {
    test('fragment shader renders sampler with filter quality ${filterQuality.name}', () async {
      final ui.Image image = _createOvalGradientImage(imageDimension: 16);

      final ui.FragmentProgram program = await renderer.createFragmentProgram('texture_shader');
      final ui.FragmentShader shader = program.fragmentShader();

      // Resolution
      shader.getUniformFloat('u_size', 0).set(region.width);
      shader.getUniformFloat('u_size', 1).set(region.height);

      // Image
      shader.setImageSampler(0, image, filterQuality: filterQuality);

      final recorder = ui.PictureRecorder();
      final canvas = ui.Canvas(recorder, region);
      canvas.drawRect(
        ui.Rect.fromLTRB(0, 0, region.width, region.height),
        ui.Paint()..shader = shader,
      );

      await drawPictureUsingCurrentRenderer(recorder.endRecording());

      await matchGoldenFile(goldenFilename, region: region);
    }, skip: isWimp); // https://github.com/flutter/flutter/issues/175431
  }

  test('getUniformFloat works with correct datatype', () async {
    final ui.FragmentProgram program = await renderer.createFragmentProgram('ink_sparkle');
    final ui.FragmentShader shader = program.fragmentShader();
    final ui.UniformFloatSlot slot = shader.getUniformFloat('u_rotation1', 1);
    expect(slot.shaderIndex, equals(27));
  });

  test('getUniformVec2 works with correct datatype', () async {
    final ui.FragmentProgram program = await renderer.createFragmentProgram('many_arrays');
    final ui.FragmentShader shader = program.fragmentShader();
    shader.getUniformVec2('uSize').set(6.0, 7.0);
  });
  test('getUniformVec3 works with correct datatype', () async {
    final ui.FragmentProgram program = await renderer.createFragmentProgram('many_arrays');
    final ui.FragmentShader shader = program.fragmentShader();
    shader.getUniformVec3('uLoneVector').set(11.0, 22.0, 19.96);
  });

  test('getUniformVec4 works with correct datatype', () async {
    final ui.FragmentProgram program = await renderer.createFragmentProgram('ink_sparkle');
    final ui.FragmentShader shader = program.fragmentShader();
    shader.getUniformVec4('u_color').set(0.8, 0.1, 0.3, 1.0);
  });

  group('Uniform by-name accessors throw errors with incorrect datatypes.', () {
    late ui.FragmentProgram program;
    late ui.FragmentShader shader;
    setUp(() async {
      program = await renderer.createFragmentProgram('many_arrays');
      shader = program.fragmentShader();
    });
    test('getUniformVec2', () {
      expect(
        () => shader.getUniformVec2('uLoneMatrix'),
        throwsA(
          isA<ArgumentError>().having(
            (e) => e.message,
            'message',
            'Uniform `uLoneMatrix` has size 16, not size 2.',
          ),
        ),
      );
    });
    test('getUniformVec3', () {
      expect(
        () => shader.getUniformVec3('uSize'),
        throwsA(
          isA<ArgumentError>().having(
            (e) => e.message,
            'message',
            'Uniform `uSize` has size 2, not size 3.',
          ),
        ),
      );
    });
    test('getUniformVec4', () {
      expect(
        () => shader.getUniformVec4('uLoneMatrix'),
        throwsA(
          isA<ArgumentError>().having(
            (e) => e.message,
            'message',
            'Uniform `uLoneMatrix` has size 16, not size 4.',
          ),
        ),
      );
    });
  });
}

// Image of an oval painted with a linear gradient.
ui.Image _createOvalGradientImage({required int imageDimension}) {
  final recorder = ui.PictureRecorder();
  final canvas = ui.Canvas(recorder);
  canvas.drawPaint(ui.Paint()..color = const ui.Color(0xFF000000));
  canvas.drawOval(
    ui.Rect.fromCenter(
      center: ui.Offset(imageDimension * 0.5, imageDimension * 0.5),
      width: imageDimension * 0.6,
      height: imageDimension * 0.9,
    ),
    ui.Paint()
      ..shader = ui.Gradient.linear(
        ui.Offset.zero,
        ui.Offset(imageDimension.toDouble(), imageDimension.toDouble()),
        [const ui.Color(0xFFFF0000), const ui.Color(0xFF00FF00)],
      ),
  );
  final ui.Picture picture = recorder.endRecording();
  try {
    return picture.toImageSync(imageDimension, imageDimension);
  } finally {
    picture.dispose();
  }
}
